<head>
  <script src="js/3d-force-graph.min.js"></script>
  <link rel="stylesheet" type="text/css" href="css/w2ui-1.5.rc1.css" />
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script type="text/javascript" src="js/w2ui-1.5.rc1.min.js"></script>
  <!--<script src="../../dist/3d-force-graph.js"></script>-->
</head>
<script>
    //workaround for cross domain origin requests issue
document.domain = document.domain;
</script>

<style>
    body { margin: 20; background-color:black }
    .tab {
        width: 100%;
        height: 100%;
        border: 1px solid silver;
        border-top: 0px;
        display: none;
        padding: 10px;
        overflow: auto;
    }
</style>

<body >

<!-- Tabs divs using https://github.com/vitmalina/w2ui/ -->
<div id="tab-example">
    <div id="tabs" style="width: 100%; height: 29px;"></div>



    <!-- <div id="tab1" class="tab">
        <div id="3d-graph"></div>
    </div> -->
    <div id="tab1" class="tab">
        <iframe src="code.html" height="100%" width="100%"></iframe>
    </div>
    <div id="tab2" class="tab">
        <iframe src="http://localhost:8088/terminal" height="100%" width="100%"></iframe>
    </div>
    <!-- <div id="tab3" class="tab">
        <iframe src="http://localhost:3000" height="100%" width="100%"></iframe>
    </div> -->
    <div id="tab3" class="tab">
        <input top=5px id="server" type="text" value="ws://localhost:8080" size="40">
    </div>
</div>

<!-- Tabs mechanism using https://github.com/vitmalina/w2ui/ -->
<script>
var config = {
    tabs: {
        name: 'tabs',
        active: 'tab1',
        tabs: [
            { id: 'tab1', caption: 'Code' },
            { id: 'tab2', caption: 'Terminal' },
            // { id: 'tab3', caption: 'Commit Board' },
            { id: 'tab3', caption: 'State' },
        ],
        onClick: function (event) {
            $('#tab-example .tab').hide();
            $('#tab-example #' + event.target).show();
        }
    }
}

$(function () {
    $('#tabs').w2tabs(config.tabs);
    $('#tab1').show();
});


        
// note: maxWidth serves to clamp the link.numfiles value so that we don't a giant width for those commits with 100s-1000s of files
let maxWidth = 10;
// similarly, maxVal clamps the node.numFiles value so the node size isn't too big
let maxVal = 50;
// eventually write either a dynamic scaler which takes the largest value as the global maximum. or figure something else out... 
//////////

var ws_url = "ws://" + window.location.host;

//document.getElementById('server').value = ws_url;
function log (message) {
  console.log(message)
}

function openTerminal () {
  var terminalHost = "http://" + location.host.substr(0, location.host.indexOf(':')) + ':8088';
  // var childWindow = "";
  window.open(terminalHost)
  
  // childWindow = window.open(terminalHost)
  // setTimeout(
  //   function() {
  //     childWindow.location.href=terminalHost;

  //   }, 2000);
}
openSocket();
function openSocket() {
    
    var url = document.getElementById('server').value;
    ws = new WebSocket(ws_url);
    ws.binaryType = 'arraybuffer';
    ws.onopen = function() {
        ws.send("connected")
        //w
        // log('open');     
        // ws.send("client_SVG?")

        // ws.send("getCurrentBranch")
        
        // //temporary: for now set user as Guest so I don't have to keep choosing user while developing. 
        // ws.send("selectUser?" + "Guest");
        
        sessionStorage.echoServer = url;
    };
    ws.onclose = function() {
        // log('close');
    };
    ws.onmessage = function(e) {
        /*if (e.data instanceof Blob) {
            var reader = new FileReader();
            reader.onload = function(e) {
                log('received blob: ' + encodeHexString(new Uint8Array(e.target.result)));
            };
            reader.readAsArrayBuffer(e.data);
        } else */
        if (e.data instanceof ArrayBuffer) {
            //log(encodeHexString(new Uint8Array(e.data)));
            //log("received arraybuffer size: " + e.data.byteLength + " bytes");
            
            let s = "";
            let fv = new Float32Array(e.data);
            for (var i = 0; i < fv.length; i+=3) {
                s += "<li>" + (i/3 + ": { " + fv[i] + ", " + fv[i+1] + ", " + fv[i+2] + " }</li>");
            }
            
            // document.getElementById('state').innerHTML = s;     
            // git yer life together
            // gitTFO
            // git over yourself
            // git your ouevre together
            // git me a sangwich
            // sudo git me a sandwich, please
            // git with the program
            // git outta my office
            // how about i give you the finger: ..|.. and you git me my phone call
            // 
        } else {
            let message = e.data;
            let q = message.indexOf("?");
            if (q > 0) {
                let cmd = message.substring(0, q);
                let arg = message.substring(q+1);
                switch(cmd) {

                    case "source": 
                    let source = JSON.parse(arg)

                    //let fileCount = (node.commit_files)
                    //console.log("filecount " + fileCount)
                    const elem = document.getElementById('3d-graph');
                    const Graph = ForceGraph3D()(elem)
                    // .jsonUrl('http://localhost:8080/blocks.json')
                    .graphData(source)
                    .nodeAutoColorBy('user')
                    .nodeLabel(node => `${node.commit_date} - ${node.name}: ${node.commit_msg}`)
                    .linkLabel(link => `${link.numfiles} files changed`)
                    .onNodeHover(node => elem.style.cursor = node ? 'pointer' : null)
                    .nodeVal(node => Math.min(Math.max(1, node.numFiles), maxVal))
                    .nodeRelSize(1)
                    .onNodeClick(node => window.open(`https://github.com/michaelpalumbo/gitShow/commit/${node.id}`, '_blank') && ws.send("clickedHash?" + node.id))
                   /* .linkDirectionalArrowLength(5.5)
                    .linkDirectionalArrowRelPos(0.5)
                    .linkLabel(node => `${node.commit_date}`)
                    .linkWidth(1)
                    */
                    //.linkCurvature(0.2)
                    
                    .linkCurvature(0.25)

                    .linkWidth(link => Math.min(Math.max(1, link.numfiles), maxWidth))
                    //.linkDirectionalParticles(node => `${node.commit_files.length - 1}`) //todo: can we get the number of particles on a link to correspond to the number of files in that commit?
                    .linkDirectionalParticles(1)
                    .linkDirectionalParticleSpeed(0.01)
                    .linkDirectionalParticleWidth(1.2)
                    .linkDirectionalParticleResolution(8);


                    break;

             
                    // case "state":
                    // //we need to clear the table rows (except for the first, since [1]in order to add after last we need something there already, annnnd the 0th table row is our table header!)
                    // $("#stateValues").find("tr:gt(0)").remove(); 
                    
                    // state = (JSON.parse(arg))
                    // let offset;
                    // let type;
                    // let pName;
                    // let pValue;
                    // Object.keys(state).forEach(function(key, value) {
                    //     //console.log(state[key].paramName)
                    //     pName;

                    //      type = state[key].type;
                    //      pName = state[key].paramName;
                    //      pValue = state[key].paramValue;
                        
                    //     // for ( property in state[key] ) {
                    //     //     //console.log( property ); // Outputs: foo, fiz or fiz, foo
                    //     //     pName = property
                    //     //     //console.log(property[0], property[1], property[2])
                    //     // }
                    //     // //console.log(pValue)
                    //     // let array = Object.values(state[key])[0]
                        
                    //     // offset = array[2];
                    //     // type = array[1];
                        
                    //     // pValue = array[0];

                    //     //console.log(array)

                    //     //different types will require different ui elements.
                    //     switch (type) {
                            
                    //         // a float or an int will use the jquery spinner
                    //         case "float":

                    //         $('#stateValues tr:last').after('<tr><td>' + pName + '</td><td>' + '<input id=\"' + pName + '\" class="param" onchange="updateState(this)" value=\"' + pValue + '\"></input>' + '</td></tr>');
                    //         //turn the input element into a jquery spinner
                    //         $("#" + pName).spinner();
                    //         //have the spinner report its value whenever it gets changed by mouse or keyboard events.
                    //         $( "#" + pName ).spinner({spin: function( event, ui, id ) {
                    //             updateState(this.id, ui.value);
                    //             }
                    //         });
                    //         $("#" + pName).data('mmapData', { offset: offset })
                    //         break;
                            
                    //         //for params whose type we haven't yet figure out how to retrieve (if they are vec3, for example)
                    //         default:

                    //         var li = document.createElement('li');
                    //         var list = document.getElementById('otherParams');

                    //         li.innerHTML = ("Parameter: " + pName + " Type: " + type);
                    //         list.appendChild(li);

                    //         var chatMessages = document.querySelector('#otherParams');
                    //         chatMessages.scrollTop = chatMessages.scrollHeight - chatMessages.clientHeight;
                    //         break;
                    //     }
                    // })




                    default:
                    break;

                    }
        
                } else {
            
                log('received: ' + e.data);
                }
            }
        };
    ws.onerror = function() {
        log('error');
    };
}

function closeSocket() {
    log('closing');
    ws.close();
}

// // keep checking socket status, re-open if closed:
// setInterval(function(){
//         if (!ws || ws.readyState === WebSocket.CLOSED) openSocket();
// }, 2000);






    
    </script>
  </body>
  